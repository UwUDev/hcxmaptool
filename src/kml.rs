use crate::AccessPoint;
use log::{info, warn};
use std::fs::File;
use std::io::{Result as IoResult, Write};

pub fn export_to_kml(access_points: &[AccessPoint], filename: &str) -> IoResult<()> {
    let mut file = File::create(filename)?;

    writeln!(file, r#"<?xml version="1.0" encoding="UTF-8"?>"#)?;
    writeln!(file, r#"<kml xmlns="http://www.opengis.net/kml/2.2">"#)?;
    writeln!(file, "  <Document>")?;
    writeln!(file, "    <name>WiFi Access Points</name>")?;
    writeln!(
        file,
        "    <description>Autogenerated KML file with {}</description>",
        env!("CARGO_PKG_NAME")
    )?;

    write_style(
        &mut file,
        "security-unknown",
        "http://maps.google.com/mapfiles/kml/paddle/purple-blank.png",
    )?;
    write_style(
        &mut file,
        "security-open",
        "http://maps.google.com/mapfiles/kml/paddle/wht-circle.png",
    )?;
    write_style(
        &mut file,
        "security-wep",
        "http://maps.google.com/mapfiles/kml/paddle/blu-circle.png",
    )?;
    write_style(
        &mut file,
        "security-wpa",
        "http://maps.google.com/mapfiles/kml/paddle/ylw-circle.png",
    )?;
    write_style(
        &mut file,
        "security-wpa2",
        "http://maps.google.com/mapfiles/kml/paddle/orange-circle.png",
    )?;
    write_style(
        &mut file,
        "security-wpa3",
        "http://maps.google.com/mapfiles/kml/paddle/red-circle.png",
    )?;
    write_style(
        &mut file,
        "password-known",
        "http://maps.google.com/mapfiles/kml/paddle/grn-stars.png",
    )?;

    let mut count = 0;
    let mut unknown_ssid_count = 0;
    let mut unknown_security_count = 0;

    for ap in access_points
        .iter()
        .filter(|ap| ap.estimated_position.is_some())
    {
        if let Some(ref pos) = ap.estimated_position {
            let mac = format!(
                "{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
                ap.mac[0], ap.mac[1], ap.mac[2], ap.mac[3], ap.mac[4], ap.mac[5]
            );

            // sanitize SSID for XML
            let ssid = ap
                .ssid
                .as_ref()
                .map(|s| sanitize_for_xml(s))
                .unwrap_or_else(|| {
                    unknown_ssid_count += 1;
                    format!("Unknown SSID {}", unknown_ssid_count)
                });

            // get security level
            let security = ap
                .security
                .as_ref()
                .map(|s| s.to_string())
                .unwrap_or_else(|| {
                    unknown_security_count += 1;
                    "Unknown".to_string()
                });

            // calculate signal statistics
            let signals: Vec<i8> = ap.observations.iter().map(|o| o.signal_strength).collect();
            let min_rssi = signals.iter().min().copied().unwrap_or(0);
            let max_rssi = signals.iter().max().copied().unwrap_or(0);
            let avg_rssi = if !signals.is_empty() {
                signals.iter().map(|&s| s as f64).sum::<f64>() / signals.len() as f64
            } else {
                0.0
            };

            // determine style based on security and password presence
            let style = if ap.password.is_some() {
                "password-known"
            } else {
                match ap.security.as_ref().map(|s| s.to_string()).as_deref() {
                    Some("Open") => "security-open",
                    Some("WEP") => "security-wep",
                    Some("WPA") => "security-wpa",
                    Some("WPA2") => "security-wpa2",
                    Some("WPA3") | Some("WPA2/WPA3") => "security-wpa3",
                    _ => "security-unknown",
                }
            };

            writeln!(file, "    <Placemark>")?;
            writeln!(file, "      <name>{}</name>", ssid)?;
            writeln!(file, "      <description>")?;
            writeln!(file, "SSID: {}", ssid)?;
            writeln!(file, "Security: {}", security)?;
            writeln!(file, "MAC: {}", mac)?;
            if let Some(ref password) = ap.password {
                writeln!(file, "Password: {}", sanitize_for_xml(password))?;
            }
            if let Some(ref vendor) = ap.vendor {
                writeln!(file, "Vendor: {}", sanitize_for_xml(vendor))?;
            }
            writeln!(file, "Observations: {}", ap.observations.len())?;
            writeln!(
                file,
                "Method: {}",
                ap.position_method
                    .as_ref()
                    .unwrap_or(&"unknown".to_string())
            )?;
            writeln!(
                file,
                "Signal: {} to {} dBm (avg {:.1})",
                min_rssi, max_rssi, avg_rssi
            )?;
            if let Some(channel) = ap.channel {
                writeln!(file, "Channel: {}", channel)?;
            }
            writeln!(file, "      </description>")?;
            writeln!(file, "      <styleUrl>#{}</styleUrl>", style)?;
            writeln!(file, "      <Point>")?;
            writeln!(
                file,
                "        <coordinates>{:.6},{:.6},0</coordinates>",
                pos.longitude, pos.latitude
            )?;
            writeln!(file, "      </Point>")?;
            writeln!(file, "    </Placemark>")?;

            count += 1;
        }
    }

    writeln!(file, "  </Document>")?;
    writeln!(file, "</kml>")?;

    if unknown_ssid_count > 0 {
        warn!(
            "Warning: {} access points marked as having unknown SSIDs.",
            unknown_ssid_count
        );
    }

    if unknown_security_count > 0 {
        warn!(
            "Warning: {} access points marked as having unknown security types.",
            unknown_security_count
        );
    }

    info!("Exported {} access points to {}", count, filename);

    Ok(())
}

fn write_style(file: &mut File, id: &str, icon_url: &str) -> IoResult<()> {
    writeln!(file, "    <Style id=\"{}\">", id)?;
    writeln!(file, "      <IconStyle>")?;
    writeln!(file, "        <Icon>")?;
    writeln!(file, "          <href>{}</href>", icon_url)?;
    writeln!(file, "        </Icon>")?;
    writeln!(file, "      </IconStyle>")?;
    writeln!(file, "    </Style>")?;
    Ok(())
}

fn sanitize_for_xml(s: &str) -> String {
    s.chars()
        .filter(|&c| {
            // XML 1.0 valid characters: #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]
            let code = c as u32;
            c == '\t'
                || c == '\n'
                || c == '\r'
                || (code >= 0x20 && code <= 0xD7FF)
                || (code >= 0xE000 && code <= 0xFFFD)
        })
        .map(|c| match c {
            '&' => "&amp;".to_string(),
            '<' => "&lt;".to_string(),
            '>' => "&gt;".to_string(),
            '"' => "&quot;".to_string(),
            '\'' => "&apos;".to_string(),
            _ => c.to_string(),
        })
        .collect::<String>()
}
